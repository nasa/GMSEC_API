/*
 * Copyright 2007-2022 United States Government as represented by the
 * Administrator of The National Aeronautics and Space Administration.
 * No copyright is claimed in the United States under Title 17, U.S. Code.
 * All Rights Reserved.
 */

#include "MBWire.h"

#include <gmsec5/internal/Encoder.h>
#include <gmsec5/internal/InternalMessageFactory.h>
#include <gmsec5/internal/StringUtil.h>

#include <gmsec5/Config.h>
#include <gmsec5/GmsecException.h>
#include <gmsec5/Message.h>
#include <gmsec5/MessageFactory.h>

#include <gmsec5/util/Log.h>
#include <gmsec5/util/StdUniquePtr.h>

#include <string>


using namespace gmsec::api5;
using namespace gmsec::api5::internal;
using namespace gmsec::api5::util;

using namespace gmsec_messagebus;


bool MBWire::m_isCompress = false;



class ArrayOwner
{
public:
	ArrayOwner(char* c = NULL)
		: p(c)
	{
	}

	~ArrayOwner()
	{
		delete [] p;
	}

	char* getArray()
	{
		return p;
	}

private:
	// not implemented
	ArrayOwner(const ArrayOwner&);
	ArrayOwner& operator=(const ArrayOwner&);

	char* p;
};



void MBWire::setCompress(bool isCompress)
{
	m_isCompress = isCompress;
}


bool MBWire::isCompress()
{
	return m_isCompress;
}



// this function serializes the message into a binary format
//  MSG format
//
//  |For conpatability|
//  |with the server  |
//  |routing internals|
//  |Should be removed|
//  |once concept is  |
//  |proven           |
//  -------------------
//           |
//  <CMD_PUB>SUBJECT=<subject>[\0][msgtype:1][encoded content]
//
//  The subject is no longer double-quoted since it makes parsing harder.
//  The message contents (fields) are encoded using Encoder.h support.

void MBWire::serialize(const Message& message, char*& data, GMSEC_I32& size)
{
	// first get the buffer size required to serialize this message
	data = 0;
	size = 0;

	// serialize the content
	char*          content = 0;
	GMSEC_I32      contentSize;
	MessageEncoder encoder;

	try
	{
		GMSEC_U64 tmp;
		encoder.encode(message, tmp, content);
		contentSize = static_cast<GMSEC_I32>(tmp);
	}
	catch (const GmsecException& e)
	{
		GMSEC_WARNING << "MBWire::Serialize: content encoding error " << e.what();
		return;
	}

	if (contentSize > 100000000)
	{
		GMSEC_WARNING << "MBWire::Serialize: excessive content size " << long(contentSize);
		return;
	}

	//
	const char* subject    = message.getSubject();
	GMSEC_I32   subjectLen = static_cast<GMSEC_I32>( StringUtil::stringLength(subject) );

	// now allocate memory to hold the serialized message
	// CMD_PUB + "SUBJECT=" + <subject> + '\0' + <type>
	GMSEC_I32 preFieldSize = 1 + 8 + subjectLen + 1 + 1;
	GMSEC_I32 bufferSize   = preFieldSize + contentSize;
	char*     buffer       = new char[bufferSize];

	GMSEC_I32 cSize = 0;

	buffer[0] = CMD_PUB;
	cSize += 1;

	StringUtil::copyBytes(buffer + cSize, "SUBJECT=", 8);
	cSize += 8;

	// subject string with null terminator
	StringUtil::copyBytes(buffer + cSize, subject, subjectLen + 1);
	cSize += subjectLen + 1;

	buffer[cSize] = (unsigned char) message.getKind();
	cSize += 1;

	StringUtil::copyBytes(buffer + cSize, content, contentSize);

	data = buffer;
	size = bufferSize;
}


// this function populates the message using the format generated by Serialize()
//  MSG format
//
//  |For conpatability|
//  |with the server  |
//  |routing internals|
//  |Should be removed|
//  |once concept is  |
//  |proven           |
//  -------------------
//           |
//  SUBJECT=<subject>[\0][msgtype:1][encoded content]

#define SUBJECT_PREFIX "SUBJECT="

Message* MBWire::deserialize(const char* data, GMSEC_I32 size, MessageFactory& msgFactory, const Config& msgConfig)
{
	int index = 0;

	if (data[index] != CMD_PUB)
	{
		GMSEC_DEBUG << "MBWire::deserialize: data[0] != CMD_PUB";
		return NULL;
	}

	++index;

	// get the length of the message subject
	GMSEC_I32 subSpace = static_cast<GMSEC_I32>( StringUtil::stringLength(data + index) );

	// Ensure the length is valid
	if (subSpace <= 0 || static_cast<GMSEC_U32>(subSpace) > GMSEC_STRING_LIMIT)
	{
		GMSEC_ERROR << "MBWire::deserialize: invalid message subject length; got " << subSpace << " bytes";
		return NULL;
	}

	GMSEC_I32 startLen = static_cast<GMSEC_I32>( StringUtil::stringLength(SUBJECT_PREFIX) );

	if (subSpace < startLen)
	{
		GMSEC_ERROR << "MBWire::deserialize: subSpace is not big enough for " SUBJECT_PREFIX;
		return NULL;
	}

	if (StringUtil::stringCompareCount(data + index, SUBJECT_PREFIX, startLen) != 0)
	{
		GMSEC_ERROR << "MBWire::deserialize: subSpace does not start with " SUBJECT_PREFIX;
		return NULL;
	}

	GMSEC_I32   subBegin  = index + startLen;
	GMSEC_I32   subLength = subSpace - subBegin + 1;
	const char* subject   = data + subBegin;

	index += subSpace + 1;

	// skip the message kind
	index += 1;

	// create the GMSEC message; first construct the subject
	std::string tmpSubject(subject, subLength);

	Message* message = NULL;

	try
	{
		StdUniquePtr<Message> gmsecMessage( MessageFactoryBuddy::getInternal(msgFactory).newMessage() );

		gmsecMessage->setSubject(tmpSubject.c_str());
		gmsecMessage->setConfig(msgConfig);

		MessageDecoder decoder;

		decoder.decode(*gmsecMessage.get(), size - index, &data[index]);

		message = gmsecMessage.release();
	}
	catch (const GmsecException& e)
	{
		GMSEC_WARNING << "MBWire::deserialize: unable to create Message: " << e.what();
	}

	return message;
}
